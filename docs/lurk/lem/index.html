<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lurk Evaluation Model (LEM)"><title>lurk::lem - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="lurk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (8ca44ef9c 2023-07-10)" data-channel="nightly" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../lurk/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../lurk/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module lem</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">lurk</a>::<wbr><a class="mod" href="#">lem</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/lurk/lem/mod.rs.html#1-497">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h3 id="lurk-evaluation-model-lem"><a href="#lurk-evaluation-model-lem">Lurk Evaluation Model (LEM)</a></h3>
<p>A LEM is a description of Lurk’s evaluation algorithm, encoded as data. In
other words, it’s a meta-representation of Lurk’s step function.</p>
<p>The motivation behind LEM is the fact that hand-writing the circuit is a
fragile process that hinders experimentation and safety. Thus we would like
to bootstrap the circuit automatically, given a higher level description of
the step function.</p>
<p>LEM also allows the <code>Store</code> API to be completely abstracted away from the
responsibilities of LEM authors. Indeed, we want the implementation details
of the <code>Store</code> not to be important at LEM definition time.</p>
<h4 id="data-semantics"><a href="#data-semantics">Data semantics</a></h4>
<p>A LEM describes how to handle pointers with variables, which are
basically named references. Instead of saying <code>let foo ...</code> in Rust, we
use a <code>Var(&quot;foo&quot;)</code> in LEM.</p>
<p>The actual algorithm is encoded with a LEM operation (<code>LEMOP</code>). It’s worth
noting that one of the LEM operators is in fact a vector of operators, which
allows imperative/sequenced expressiveness.</p>
<h4 id="interpretation"><a href="#interpretation">Interpretation</a></h4>
<p>Running a LEM is done via interpretation, which might be a bit slower than
calling Rust functions directly. But it also has its advantages:</p>
<ol>
<li>
<p>The logic to collect data during execution can be factored out from the
definition of the step function. This process is needed in order to evidence
the inputs for the circuit at proving time;</p>
</li>
<li>
<p>Actually, such logic to collect data is a natural consequence of the fact
that we’re on a higher level of abstraction. Relevant data is not simply
stored on rust variables that die after the function ends. On the contrary,
all relevant data lives on data structures that are also a product of the
interpreted LEM.</p>
</li>
</ol>
<h4 id="constraining"><a href="#constraining">Constraining</a></h4>
<p>This is the process of creating the circuit, which we want to be done
automatically for whoever creates a LEM. Each <code>LEMOP</code> has to be precisely
constrained in such a way that the resulting circuits accepts a witness iff
it was generated by a valid interpretation of the LEM at play.</p>
<h4 id="static-checks-of-correctness"><a href="#static-checks-of-correctness">Static checks of correctness</a></h4>
<p>Since a LEM is an algorithm encoded as data, we can perform static checks of
correctness as some form of (automated) formal verification. Here are some
(WIP) properties we want a LEM to have before we can adopt it as a proper
Lurk step function:</p>
<ol>
<li>
<p>Non-duplicated input labels: right at the start of interpretation, the
input labels are bound to the actual pointers that represent the expression,
environment and continuation. If some label is repeated, semantics become
confusing;</p>
</li>
<li>
<p>Assign first, use later: this prevents obvious errors such as “x not
defined” during interpretation or “x not allocated” during constraining.</p>
</li>
</ol>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LEM.html" title="struct lurk::lem::LEM">LEM</a></div><div class="desc docblock-short">A <code>LEM</code> has the name for the inputs and its characteristic control node</div></li><li><div class="item-name"><a class="struct" href="struct.Var.html" title="struct lurk::lem::Var">Var</a></div><div class="desc docblock-short">Named references to be bound to <code>Ptr</code>s.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.LEMCTL.html" title="enum lurk::lem::LEMCTL">LEMCTL</a></div><div class="desc docblock-short">The basic control nodes for LEM logical paths.</div></li><li><div class="item-name"><a class="enum" href="enum.LEMOP.html" title="enum lurk::lem::LEMOP">LEMOP</a></div><div class="desc docblock-short">The atomic operations of LEMs.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AString.html" title="type lurk::lem::AString">AString</a></div></li><li><div class="item-name"><a class="type" href="type.AVec.html" title="type lurk::lem::AVec">AVec</a></div></li></ul></section></div></main></body></html>