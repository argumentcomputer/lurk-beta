<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `memoset` module implements a `MemoSet`."><title>lurk::coroutine::memoset - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="lurk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../lurk/index.html">lurk</a><span class="version">0.3.1</span></h2></div><h2 class="location"><a href="#">Module memoset</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In lurk::coroutine</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../lurk/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">lurk</a>::<wbr><a href="../index.html">coroutine</a>::<wbr><a class="mod" href="#">memoset</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/lurk/coroutine/memoset/mod.rs.html#1-1433">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <code>memoset</code> module implements a <code>MemoSet</code>.</p>
<p>A <code>MemoSet</code> is an abstraction we use to memoize deferred proof of (potentially mutually-recursive) query results.
Whenever a computation being proved needs the result of a query, the prover non-deterministically supplies the
correct result. The resulting key-value pair is then added to a multiset representing deferred proofs. The
dependent proof now must not be accepted until every element in the deferred-proof multiset has been proved.</p>
<p>Implementation depends on a cryptographic multiset – for example, ECMH or LogUp (implemented here). This allows us
to prove that every element added to to the multiset is later removed only after having been proved. The
cryptographic assumption is that it is infeasible to fraudulently demonstrate multiset equality.</p>
<p>Our use of the LogUp (logarithmic derivative) technique in the <code>LogMemo</code> implementation of <code>MemoSet</code> unfortunately
requires that the entire history of insertions and removals be committed to in advance – so that Fiat-Shamir
randomness derived from the transcript can be used when mapping field elements to multiset elements. We use Lurk
data to assemble the transcript, so that the final randomness is the hash/value component of a <code>ZPtr</code> to the
content-addressed data structure representing the transcript as assembled.</p>
<p>Transcript elements represent deferred proofs that are either added to (when their results are used) or removed from
(when correctness of those results is proved) the ‘deferred proof’ multiset. Insertions are recorded in the
transcript as key-value pairs (Lurk data: <code>(key . value)</code>); and removals further include the removal multiplicity
(Lurk data: <code>((key . value) . multiplicity)</code>). It is critical that the multiplicity be included in the transcript,
since if free to choose it after the randomness has been derived, the prover can trivially falsify the contents of
the multiset – decoupling claimed truths from those actually proved.</p>
<p>Bookkeeping required to correctly build the transcript after evaluation but before proving is maintained by the
<code>Scope</code>. This allows us to accumulate queries and the subqueries on which they depend, along with the memoized query
results computed ‘naturally’ during evaluation. We then separate and sort in an order matching that which the NIVC
prover will follow when provably maintaining the multiset accumulator and Fiat-Shamir transcript in the circuit.</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AllocatedProvenance.html" title="struct lurk::coroutine::memoset::AllocatedProvenance">AllocatedProvenance</a></div></li><li><div class="item-name"><a class="struct" href="struct.CircuitScope.html" title="struct lurk::coroutine::memoset::CircuitScope">CircuitScope</a></div></li><li><div class="item-name"><a class="struct" href="struct.CircuitTranscript.html" title="struct lurk::coroutine::memoset::CircuitTranscript">CircuitTranscript</a></div></li><li><div class="item-name"><a class="struct" href="struct.CoroutineCircuit.html" title="struct lurk::coroutine::memoset::CoroutineCircuit">CoroutineCircuit</a></div></li><li><div class="item-name"><a class="struct" href="struct.LogMemo.html" title="struct lurk::coroutine::memoset::LogMemo">LogMemo</a></div></li><li><div class="item-name"><a class="struct" href="struct.LogMemoCircuit.html" title="struct lurk::coroutine::memoset::LogMemoCircuit">LogMemoCircuit</a></div></li><li><div class="item-name"><a class="struct" href="struct.Provenance.html" title="struct lurk::coroutine::memoset::Provenance">Provenance</a></div></li><li><div class="item-name"><a class="struct" href="struct.Scope.html" title="struct lurk::coroutine::memoset::Scope">Scope</a></div><div class="desc docblock-short">A <code>Scope</code> tracks the queries made while evaluating, including the subqueries that result from evaluating other
queries – then makes use of the bookkeeping performed at evaluation time to synthesize proof of each query
performed.</div></li><li><div class="item-name"><a class="struct" href="struct.Transcript.html" title="struct lurk::coroutine::memoset::Transcript">Transcript</a></div></li></ul><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.MemoSetError.html" title="enum lurk::coroutine::memoset::MemoSetError">MemoSetError</a></div></li></ul><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.CircuitMemoSet.html" title="trait lurk::coroutine::memoset::CircuitMemoSet">CircuitMemoSet</a></div></li><li><div class="item-name"><a class="trait" href="trait.CircuitQuery.html" title="trait lurk::coroutine::memoset::CircuitQuery">CircuitQuery</a></div></li><li><div class="item-name"><a class="trait" href="trait.MemoSet.html" title="trait lurk::coroutine::memoset::MemoSet">MemoSet</a></div></li><li><div class="item-name"><a class="trait" href="trait.Query.html" title="trait lurk::coroutine::memoset::Query">Query</a></div></li></ul></section></div></main></body></html>